---
type Card = { quote: string; author: string; signature?: string };

type Props = {
  title: string;
  underline?: string;
  pinVh?: number;
  cards: Card[];
};

const { title, underline = "", pinVh = 220, cards = [] } = Astro.props;
---

<section id="testimonials" class="tst" data-pin-vh={pinVh}>
  <div class="tst__inner">
    <header class="tst__header">
      <h2 class="tst__title">{title}</h2>
      {underline && <img class="tst__underline" src={underline} alt="" loading="lazy" />}
    </header>

    <div class="tst__stage" aria-hidden="true">
      {cards.map((c, i) => (
        <article class="tst__card" data-i={i}>
          <p class="tst__quote">{c.quote}</p>
          <div class="tst__sig">
            <span class="tst__author">{c.author}</span>
            {c.signature && <span class="tst__signature">{c.signature}</span>}
          </div>
        </article>
      ))}
    </div>
  </div>

<script is:inline>
  (function () {
    const root = document.currentScript?.closest(".tst");
    if (!root) return;

    const stage = root.querySelector(".tst__stage");
    const header = root.querySelector(".tst__header");
    const cards = Array.from(root.querySelectorAll(".tst__card"));
    if (!stage || cards.length === 0) return;

    const pinVh = Number(root.getAttribute("data-pin-vh") || "220");

    function clamp(n, min, max) { 
      return Math.max(min, Math.min(max, n)); 
    }

    function rectsOverlap(a, b, pad) {
      return !(
        a.x + a.w + pad < b.x ||
        a.x > b.x + b.w + pad ||
        a.y + a.h + pad < b.y ||
        a.y > b.y + b.h + pad
      );
    }

    function layoutDistributed() {
      const rect = stage.getBoundingClientRect();

      const padX = Math.max(18, rect.width * 0.06);
      const padY = Math.max(18, rect.height * 0.10);

      const usableW = rect.width - padX * 2;
      const usableH = rect.height - padY * 2;

      const sizes = cards.map((card) => {
        card.style.visibility = "hidden";
        card.style.display = "block";
        const w = card.offsetWidth || 360;
        const h = card.offsetHeight || 160;
        card.style.visibility = "visible";
        return { w, h };
      });

      const total = cards.length;
      const ratio = usableW / Math.max(1, usableH);

      let cols = Math.ceil(Math.sqrt(total * ratio));
      let rows = Math.ceil(total / cols);

      cols = clamp(cols, 2, 6);
      rows = clamp(rows, 2, 6);

      while (cols * rows < total) rows++;
      while (cols * rows > total + cols) cols = Math.max(2, cols - 1);

      const cellW = usableW / cols;
      const cellH = usableH / rows;

      const cells = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          cells.push({ c, r });
        }
      }
      for (let i = cells.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [cells[i], cells[j]] = [cells[j], cells[i]];
      }

      const placed = [];
      const overlapPad = 18;

      cards.forEach((card, i) => {
        const { w, h } = sizes[i] || { w: 360, h: 160 };
        const cell = cells[i] || cells[cells.length - 1];

        const cx = padX + cell.c * cellW + cellW * 0.5;
        const cy = padY + cell.r * cellH + cellH * 0.5;

        let x, y;
        let tries = 0;
        while (tries < 18) {
          const jx = (Math.random() - 0.5) * cellW * 0.55;
          const jy = (Math.random() - 0.5) * cellH * 0.55;

          x = cx + jx - w / 2;
          y = cy + jy - h / 2;

          x = clamp(x, padX, padX + usableW - w);
          y = clamp(y, padY, padY + usableH - h);

          const candidate = { x, y, w, h };
          const collides = placed.some((p) => rectsOverlap(candidate, p, overlapPad));

          if (!collides) {
            placed.push(candidate);
            break;
          }
          tries++;
        }

        if (tries >= 18) placed.push({ x, y, w, h });

        const rot = (Math.random() * 12) - 6;

        card.dataset.x = String(x);
        card.dataset.y = String(y);
        card.dataset.r = String(rot);

        card.style.transform = `translate(${x}px, ${y}px) rotate(${rot}deg) scale(0.96)`;
        card.style.opacity = "0";
      });
    }

    function killOwnTriggers() {
      if (!window.ScrollTrigger) return;
      window.ScrollTrigger.getAll().forEach((t) => {
        if (t.trigger === root) t.kill();
      });
    }

    function init() {
      if (!window.gsap || !window.ScrollTrigger) return;
      
      window.gsap.registerPlugin(window.ScrollTrigger);
      killOwnTriggers();

      layoutDistributed();

      window.gsap.set(header, { opacity: 1 });

      const total = cards.length;
      const perCardVh = 155;
      const extraVh = 80;
      const endVh = Math.max(pinVh, total * perCardVh + extraVh);

      function showCount(count) {
        cards.forEach((card, idx) => {
          const on = idx < count;
          window.gsap.to(card, {
            opacity: on ? 1 : 0,
            scale: on ? 1 : 0.96,
            duration: 0.18,
            overwrite: true,
            ease: "power2.out",
          });
        });
      }

      window.ScrollTrigger.create({
        trigger: root,
        start: "top top",
        end: `+=${endVh}vh`,
        pin: true,
        scrub: true,
        invalidateOnRefresh: true,
        id: "testimonials-scroll",
        onUpdate(self) {
          const pace = 1.8;
          const stepped = Math.floor(self.progress * (total * pace));
          const count = Math.min(total, Math.floor(stepped / pace));
          showCount(count);
        },
        onRefresh() {
          layoutDistributed();
        },
      });
    }

    if (document.readyState === "complete") {
      init();
    } else {
      window.addEventListener("load", init);
    }

    let resizeTimeout;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (window.ScrollTrigger) {
          killOwnTriggers();
          init();
          window.ScrollTrigger.refresh();
        }
      }, 150);
    });
  })();
</script>

</section>
